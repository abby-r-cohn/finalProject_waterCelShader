<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Cloth Simulation</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
<h1 align="middle">Project 4: Cloth Simulator</h1>
<h2 align="middle">Abby Cohn, CS184-acy</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this project, I implemented a cloth simulator and a series of Open GL shaders. From the building of the cloth structure of masses and springs to handling collisions with other objects and the cloth itself, it was interesting to see how different data structures are helpful in speeding up simulation. It was also fascinating to implement different shaders while learning a language which was made specifically for real-time shading. </p>

<h2 align="middle">Part I: Masses and Springs</h2>

<p> To represent the masses and springs in 1D vectors, I first added all of the elements to the data structures using row-major order: [num_width_points * y + x]. The grid of masses contains num_width_points by num_height_points, so we perform the following operations num_total_mass times. With a horizontal cloth orientation, I set the y coordinate for every point mass to 1, since the material is completely flat. Otherwise, the orientation is vertical and we need a randomly generated offset for the z coordinate. In both cases, the remaining coordinates were calculated by varying positions over the xz or xy planes. I also set the mass’s pinned boolean to true for each mass contained in the pinned vector. I created the springs next by applying the structural, bending, and shearing constraints. I added each based off of certain conditions about which masses each type of constraint can exist between. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/all_constraints.png" width="450px" />
                    <figcaption align="middle">structural, shearing, and bending</figcaption>
      </td>
      <td>
         <img src="images/just_shear.png" width="450px" />
                    <figcaption align="middle">shear only</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/no_shear.png" width="450px" />
        <figcaption align="middle">structural and bending</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<h2 align="middle">Part II: Simulation via Numerical Integration</h2>

<p>The next part involved applying forces to point masses to simulate realistic movement. I calculated both external forces like gravity and spring correction forces. To get the total external force, I summed up all of the external accelerations and multiplied by the mass. For the correction forces, I used Hooke’s Law to compute the force applied to the point masses that connect the spring. I multiplied the spring constant by the magnitude of the distance between masses and subtracted the spring’s rest length. This is the force for one mass and the other has an equal (but opposite) force. Next, I used Verlet integration to calculate new point mass positions. To simulate damping, I multiplied a damping percentage by the difference between our new and last positions. I added the total acceleration and multiplied by the time-step squared. I add all of this to the current position, storing the position from the last time step as well. Fiinally , I made sure to constrain position updates by making sure that the spring’s new length is at most 10% greater than its rest length. I scaled with a correction vector and made sure that the vector direction was unchanged. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/default_settings.png" width="450px" />
        <figcaption align="middle">density: 15 g/cm^2 & ks: 5000 N/m</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/ks_9000.png" width="450px" />
                    <figcaption align="middle">ks 9000</figcaption>
      </td>
      <td>
         <img src="images/ks_1000.png" width="450px" />
                    <figcaption align="middle">ks 1000</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<p>Changing the spring constant ks creates visible changes in the cloth. When the constant is increased, the cloth springs up a little and it appears lighter in the simulation overall. When the constant is decreased, the cloth droops deeper and creates an effect of being much heavier. 
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/density_1.png" width="450px" />
                    <figcaption align="middle">density 1</figcaption>
      </td>
      <td>
         <img src="images/density_100.png" width="450px" />
                    <figcaption align="middle">density 100</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<p>I decreased the density to 1, which made the cloth super light. There were barely any folds and it looked almost paper-like. When increasing the density to 100, the cloth hangs lower and has much deeper folds, when comparing it to the default density of 15. 
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/damping.1.png" width="450px" />
                    <figcaption align="middle">damping 0.1</figcaption>
      </td>
      <td>
         <img src="images/damping.9.png" width="450px" />
                    <figcaption align="middle">damping 0.9</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<p>Turning down the damping causes more oscillation in the cloth. To slow down the oscillation, we increase the damping which acts opposite to the direction of motion. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/30_1000.png" width="450px" />
        <figcaption align="middle">pinned4 with density: 30 g/cm^2 & ks: 1000 N/m</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<h2 align="middle">Part III: Handling Collisions With Other Objects</h2>

<p>I first handled collisions with spheres, which was a bit simpler for me than intersection with planes. I calculated where the point masses should have rested on the spheres surface by comparing the distance from the origin to the point mass’s position to the radius of the sphere. I computed a correction vector using the surface intersection tangent point and applied it to the last position of the point mass and scaled by friction. I updated the simulate method to test for intersection with all of the collision objects, as well. For plane intersection, if the point mass passes over the plane, I calculate a tangent point of where the mass should have rested. Using dot products of the mass’s current and last positions with the normal, I could determine whether that mass has passed through the plane or not. If so, I use the tangent point, a correction vector, and a small surface offset to adjust the mass’s last position, finally setting it to the current position. </p>

<p>With a larger ks value, the cloth has less weight and bounces back up towards the top of the sphere when changed mid-simulation. With a lower ks, the cloth begins to droop more.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/500.png" width="450px" />
                    <figcaption align="middle">ks 500</figcaption>
      </td>
      <td>
         <img src="images/5000.png" width="450px" />
                    <figcaption align="middle">ks 5000</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/50000.png" width="450px" />
        <figcaption align="middle">ks 50000</figcaption>
      </td>
      <td>
        <img src="images/plane.png" width="450px" />
        <figcaption align="middle">plane intersection</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>


<h2 align="middle">Part IV: Handling Self-Collisions</h2>
<p>In order to keep the cloth from clipping though itself, I implemented a fix for self-collisions. Instead of looping through each pair of point masses, I used spatial hashing. Spatial hashing involves mapping a float to a vector of point masses. By creating a hash function that can uniquely map each point map position to a float, we can store points in boxes that represent specific 3D box volumes. For each point mass, we loop through the other masses that are most likely to collide with it. Thus, we can take all of the other masses in our 3D box (represented by a specific hash bucket) and compare them easily to our current mass. A small issue I had was forgetting to check if the hash bucket is not initially null. If so, I needed to populate it with a vector, since the current point mass would be the first member of that bucket. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/early.png" width="400px" />
        <figcaption align="middle">3 seconds in</figcaption>
      </td>
      <td>
        <img src="images/mid.png" width="500px" />
        <figcaption align="middle">about 9 seconds in</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/rest.png" width="500px" />
        <figcaption align="middle">resting state</figcaption>
      </td>
      <td>
        <img src="images/rest_top.png" width="200px" />
        <figcaption align="middle">resting state top view</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<p>Below are images of the cloth with the density and ks values changed from the defaut values. When the ks is increased, there are larger folds with less wrinkles and the cloth appears more stiff. With a lower ks value, there are more wrinkles and the cloth is less stiff. Increasing the density created many more folds while decreasing density created wider folds with a more neat, less wrinkly resting state. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/d_2000.png" width="400px" />
        <figcaption align="middle">ks 2000</figcaption>
      </td>
      <td>
        <img src="images/d_50000.png" width="450px" />
        <figcaption align="middle">ks 50000</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/5.png" width="400px" />
        <figcaption align="middle">density 5</figcaption>
      </td>
      <td>
        <img src="images/40.png" width="300px" />
        <figcaption align="middle">density 40</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<h2 align="middle">Part V: Shaders</h2>
<p>In this section, I implemented some GLSL shaders, which run parallel on GPU, speeding up render time from the raytracing done in previous projects. GLSL is a language that has two basic shader types that take inputs and give back a 4-dimensional vector: vertex shaders and fragment shaders. Vertex shaders apply transforms to verticies while fragment shaders compute output colors. </p>

<p> I first implemented diffuse shading, which uses the formula for diffuse lighting: Ld = kd(I/r^2)max(0, dot(n, l)). This was a fragment shader, so I wrote the final color to out_color. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/diffuse.png" width="450px" />
        <figcaption align="middle">diffuse shader</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<p>For Blinn-Phong shading, I built upon the diffuse shader to add ambient light and specular components and compute the output light. Below are the effects of isolating different components of the shader as well as the entire Blinn Phong model.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/ambient.png" width="300px" />
        <figcaption align="middle">ambient</figcaption>
      </td>
      <td>
        <img src="images/spec.png" width="300px" />
        <figcaption align="middle">specular</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/diff.png" width="300px" />
        <figcaption align="middle">diffuse</figcaption>
      </td>
      <td>
        <img src="images/phong.png" width="300px" />
        <figcaption align="middle">Blinn Phong</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<p>For texture mapping with GLSL, I sampled from a texture that I chose using the built-in texture(tex, uv) function. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/my_tex.png" width="450px" />
        <figcaption align="middle">my donut texture!</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<div align="middle">

  <p>Next, I added bump mapping and displacement mapping. While bump mapping only utilizes the fragment file, the displacement map utilizes both since the actual vertices are changing position. For bump mapping, I computed local space normal by seeing how the height changes. From here we can compute small changes for u and v to get the bumped effect. For displacement mapping, I used the code from the bump fragment file, but changed the vertex file to update the positions of vertices based on the texture map. </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/bump2.png" width="300px" />
        <figcaption align="middle">bump with normal 100 height .02</figcaption>
      </td>
      <td>
        <img src="images/displace.png" width="300px" />
        <figcaption align="middle">displacement with normal 100 height .02</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<p> With a decreased coarseness, the texture appears more geometric around the eadges and we begin to see the subdivisions of the sphere(because there are less of them). With greater coarseness, there are more subdivisions and the texture looks much more smooth on the sphere. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/16_bump.png" width="300px" />
        <figcaption align="middle">bump with coarseness 16</figcaption>
      </td>
      <td>
        <img src="images/16_disp.png" width="300px" />
        <figcaption align="middle">displacement with coarseness 16</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/bump_128.png" width="300px" />
        <figcaption align="middle">bump with coarseness 128</figcaption>
      </td>
      <td>
        <img src="images/disp_128.png" width="300px" />
        <figcaption align="middle">displacement with coarseness 128</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<p> Finally, I added a mirror shader that samples from the u_texture_cubemap and utilizes the built in texture function again. I computed the outgoing eye ray and reflected it across the surface normal to get the incoming direction</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/mirror.png" width="300px" />
        <figcaption align="middle">mirror on cloth</figcaption>
      </td>
      <td>
        <img src="images/ms.png" width="300px" />
        <figcaption align="middle">mirror on sphere</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
  

</body>
</html>

